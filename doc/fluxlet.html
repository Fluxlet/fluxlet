<!DOCTYPE html><html lang="en"><head><title>fluxlet</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="fluxlet"><meta name="groc-project-path" content="src/fluxlet.js"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/fluxlet.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="fluxlet">Fluxlet</h1></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fluxlet uses a fluent API to construct an instance, a fluxlet can be named or annonymous.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Internal map of named fluxlets</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> fluxlets = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create or retrieve a fluxlet</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(id)</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return an existing fluxlet by id if it exists</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (id &amp;&amp; fluxlets[id]) {
        <span class="hljs-keyword">return</span> fluxlets[id];
    }

    <span class="hljs-keyword">const</span> instance = createFluxlet(id);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Anonymous fluxlets are not stored</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (id) {
        fluxlets[id] = instance;
    }

    <span class="hljs-keyword">return</span> instance;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFluxlet</span><span class="hljs-params">(id)</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A function that validates states as they are passed around</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">let</span> stateValidator = <span class="hljs-literal">undefined</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The state of the fluxlet between dispatches</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">let</span> lockedState = <span class="hljs-literal">undefined</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The current action in dispatch</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">let</span> dispatching = <span class="hljs-literal">undefined</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The map of action dispatchers</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> dispatchers = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The list of state calculation functions</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> calculations = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The list of side effect functions</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> sideEffects = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Log category settings</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> logging = {
        register: <span class="hljs-literal">true</span>,
        dispatch: <span class="hljs-literal">true</span>,
        call: <span class="hljs-literal">true</span>,
        state: <span class="hljs-literal">false</span>
    };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Handy string for use in log and error messages</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> logId = <span class="hljs-string">`fluxlet:<span class="hljs-subst">${id||'(anon)'}</span>`</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set to true on the first action dispatch,
after which certain aspects of the fluxlet may not be modified</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> live = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span><span class="hljs-params">(category, type, name, args)</span> </span>{
        <span class="hljs-keyword">if</span> (logging[category]) {
            <span class="hljs-keyword">if</span> (args &amp;&amp; args.length) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${logId}</span> <span class="hljs-subst">${category}</span> <span class="hljs-subst">${type}</span>:<span class="hljs-subst">${name}</span>`</span>, ...args);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${logId}</span> <span class="hljs-subst">${category}</span> <span class="hljs-subst">${type}</span>:<span class="hljs-subst">${name}</span>`</span>);
            }
        }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a dispatcher function for an action</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDispatcher</span><span class="hljs-params">(action, type, name)</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is the dispatcher function, created for the given action.
It args are passed through to the action function later.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> (...args) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The fluxlet become &#39;live&#39; on the first action dispatch</p></div></div><div class="code"><div class="wrapper">            live = <span class="hljs-literal">true</span>;

            log(<span class="hljs-string">"dispatch"</span>, type, name, args);

            <span class="hljs-keyword">if</span> (dispatching) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This dispatch will fail if called directly from within another dispatch</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">throw</span> (<span class="hljs-string">`Attempt to dispatch action '<span class="hljs-subst">${name}</span>' within action '<span class="hljs-subst">${dispatching}</span>' in <span class="hljs-subst">${logId}</span>`</span>);
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Lock the dispatcher for the current action</p></div></div><div class="code"><div class="wrapper">            dispatching = name;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the starting state</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">const</span> startState = lockedState;

            log(<span class="hljs-string">"state"</span>, <span class="hljs-string">"before"</span>, name, [startState]);

            <span class="hljs-keyword">try</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call the action with the args given to the dispatcher</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">const</span> stateManipulator = action(...args);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We expect the action to return a function that will manipulate the the state</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> stateManipulator !== <span class="hljs-string">"function"</span>) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`Action '<span class="hljs-subst">${name}</span>' did not return a function as expected in <span class="hljs-subst">${logId}</span>`</span>);
                }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pass the state the to the function returned from the action</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">let</span> newState = stateManipulator(startState);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Validate the state returned by the action</p></div></div><div class="code"><div class="wrapper">                stateValidator &amp;&amp; newState !== startState &amp;&amp; stateValidator(newState);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Chain calculation calls</p></div></div><div class="code"><div class="wrapper">                calculations.forEach(calculation =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>passing the state return from one into the next,
the starting state prior to the action is also given.</p></div></div><div class="code"><div class="wrapper">                    newState = calculation(newState, startState);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Validate the state returned by the calculation</p></div></div><div class="code"><div class="wrapper">                    stateValidator &amp;&amp; newState !== startState &amp;&amp; stateValidator(newState);
                });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store state and determine if a change has occurred</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">if</span> (newState !== startState) {
                    lockedState = newState;

                    log(<span class="hljs-string">"state"</span>, <span class="hljs-string">"after"</span>, name, [newState]);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call side-effects only if state has changed</p></div></div><div class="code"><div class="wrapper">                    sideEffects.forEach(sideEffect =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>passing the new state, original state, and all action dispatchers</p></div></div><div class="code"><div class="wrapper">                        sideEffect(newState, startState, dispatchers);
                    });
                }
            } <span class="hljs-keyword">finally</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Release lock ready for another dispatch</p></div></div><div class="code"><div class="wrapper">                dispatching = <span class="hljs-literal">undefined</span>;
            }
        };
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Wrapper for calculation and sideEffect functions, that simply logs the call</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logCall</span><span class="hljs-params">(fn, type, name)</span> </span>{
        <span class="hljs-keyword">return</span> (...args) =&gt; {
            log(<span class="hljs-string">"call"</span>, type, name, [args[<span class="hljs-number">0</span>]]);
            <span class="hljs-keyword">return</span> fn(...args);
        };
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the wrapper for action, calculation and side-effect functions or conditionals</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCall</span><span class="hljs-params">(type, name, fnOrCond, wrap)</span> </span>{
        log(<span class="hljs-string">"register"</span>, type, name);

        <span class="hljs-keyword">if</span> (fnOrCond &amp;&amp; fnOrCond.when &amp;&amp; fnOrCond.when.apply &amp;&amp; fnOrCond.then &amp;&amp; fnOrCond.then.apply) {
            <span class="hljs-keyword">return</span> conditionalCall(fnOrCond.when, wrap(fnOrCond.then, type, name));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fnOrCond &amp;&amp; fnOrCond.apply) {
            <span class="hljs-keyword">return</span> wrap(fnOrCond, type, name);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(type + <span class="hljs-string">" '"</span> + name + <span class="hljs-string">"' must be a function or an object containing a when &amp; then function"</span>);
        }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the wrapper for conditional functions</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">conditionalCall</span><span class="hljs-params">(when, then)</span> </span>{
        <span class="hljs-keyword">return</span> (...args) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A conditional is only run if its &#39;when&#39; function returns true</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (when(...args)) {
                <span class="hljs-keyword">return</span> then(...args);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>];
            }
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCalls</span><span class="hljs-params">(type, obj, wrap)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).map(name =&gt; createCall(type, name, obj[name], wrap));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">liveError</span><span class="hljs-params">(type, names)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Attempt to add <span class="hljs-subst">${type}</span> <span class="hljs-subst">${names}</span> to <span class="hljs-subst">${logId}</span> after the first action was dispatched`</span>;
    }

    <span class="hljs-keyword">return</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set the state validator function, generally only used in testing, it is expected to throw an error if it
finds the state to be invalid. It will be called, passing the state as the only arguments, on setting of
the initial state, and after each action and calculation if a new state has been returned.</p></div></div><div class="code"><div class="wrapper">        validator(validator) {
            <span class="hljs-keyword">if</span> (lockedState) {
                <span class="hljs-keyword">throw</span> (<span class="hljs-string">"The state validator should be set before the initial state of the fluxlet is set"</span>);
            }
            stateValidator = validator;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set (or modify) the initial state of the fluxlet</p></div></div><div class="code"><div class="wrapper">        state(state) {
            <span class="hljs-keyword">if</span> (live) {
                <span class="hljs-keyword">throw</span> (<span class="hljs-string">`Attempt to set state of <span class="hljs-subst">${logId}</span> after the first action was dispatched`</span>);
            }
            log(<span class="hljs-string">"create"</span>, <span class="hljs-string">"state"</span>, state);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> state === <span class="hljs-string">"function"</span>) {
                lockedState = state(lockedState);
            } <span class="hljs-keyword">else</span> {
                lockedState = state;
            }
            stateValidator &amp;&amp; stateValidator(lockedState);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add named actions to the fluxlet. An action takes some operational params,
and returns a fn that takes the whole fluxlet state and returns a new state.</p>
<pre><code>f.actions({ setName, setDateOfBirth })</code></pre></div></div><div class="code"><div class="wrapper">        actions(namedActions) {
            <span class="hljs-keyword">if</span> (live) {
                <span class="hljs-keyword">throw</span> liveError(<span class="hljs-string">'actions'</span>, <span class="hljs-built_in">Object</span>.keys(namedActions));
            }
            <span class="hljs-built_in">Object</span>.keys(namedActions).forEach(name =&gt; {
                dispatchers[name] = createCall(<span class="hljs-string">"action"</span>, name, namedActions[name], createDispatcher);
            });
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add named calculations to the fluxlet. Calculations are chained, the first is given the state
from the action, and then return value is passed into the next calculation, and so on.
They are also passed the original state prior to the action (as the 2nd arg).</p>
<pre><code>f.calculations({ makeNameUppercase, calculateAge })</code></pre></div></div><div class="code"><div class="wrapper">        calculations(namedCalculations) {
            <span class="hljs-keyword">if</span> (live) {
                <span class="hljs-keyword">throw</span> liveError(<span class="hljs-string">'calculations'</span>, <span class="hljs-built_in">Object</span>.keys(namedCalculations));
            }
            calculations.push(...createCalls(<span class="hljs-string">"calculation"</span>, namedCalculations, logCall));
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add named side-effects to the fluxlet. All side-effects receive the same final state that
resulted from the action and calculation chain, along with the original state and the map
of action dispatchers. A side-effect must not change state, or directly dispatch an action
from this same fluxlet (it may bind them to async events or timeouts though).</p>
<pre><code>f.sideEffects({ renderEverything, makeHttpRequest })</code></pre></div></div><div class="code"><div class="wrapper">        sideEffects(namedSideEffects) {
            sideEffects.push(...createCalls(<span class="hljs-string">"sideEffect"</span>, namedSideEffects, logCall));
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call a initialisation function with the map of action dispatchers.</p>
<pre><code>f.init(({ setName }) =&gt; bindChangeEventToAction(setName))</code></pre></div></div><div class="code"><div class="wrapper">        init(fn) {
            fn(dispatchers);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set logging levels</p>
<pre><code>f.logging({ call: false })</code></pre></div></div><div class="code"><div class="wrapper">        logging(categories) {
            <span class="hljs-built_in">Object</span>.keys(categories).forEach(name =&gt; { logging[name] = categories[name] });
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove a named fluxlet from the internal map of fluxlets and anonymise it</p></div></div><div class="code"><div class="wrapper">        remove() {
            <span class="hljs-keyword">if</span> (id) {
                <span class="hljs-keyword">delete</span> fluxlets[id];
                id = <span class="hljs-literal">undefined</span>;
            }
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>These tools are for testing and debugging on the console only, and should NEVER be called from code</p></div></div><div class="code"><div class="wrapper">        debug: {
            id: () =&gt; id,
            live: () =&gt; live,
            validator: () =&gt; stateValidator,
            state: () =&gt; lockedState,
            dispatching: () =&gt; dispatching,
            dispatchers: () =&gt; dispatchers,
            calculations: () =&gt; calculations,
            sideEffects: () =&gt; sideEffects
        }
    };
}</div></div></div></div></body></html>