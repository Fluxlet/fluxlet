{"name":"Fluxlet","tagline":"A micro-framework for managing state within your application","body":"[![Build Status](https://travis-ci.org/Fluxlet/fluxlet.svg?branch=master)](https://travis-ci.org/Fluxlet/fluxlet)\r\n[![npm version](https://img.shields.io/npm/v/fluxlet.svg)](https://www.npmjs.com/package/fluxlet)\r\n[![Dependency Status](https://david-dm.org/fluxlet/fluxlet.svg)](https://david-dm.org/fluxlet/fluxlet)\r\n[![devDependency Status](https://david-dm.org/fluxlet/fluxlet/dev-status.svg)](https://david-dm.org/fluxlet/fluxlet#info=devDependencies)\r\n[![Code Climate](https://codeclimate.com/github/Fluxlet/fluxlet/badges/gpa.svg)](https://codeclimate.com/github/Fluxlet/fluxlet)\r\n[![License](https://img.shields.io/github/license/fluxlet/fluxlet.svg)](LICENSE)\r\n\r\n# Fluxlet\r\n\r\nFluxlet is a micro-framework for managing state within your application.\r\n\r\nIts focus is on the predictable uni-directional flow of immutable data within\r\na single round of the event loop.\r\n\r\n\r\n## Overview\r\n\r\nData comes in from an event, an **action** is dispatched which updates the\r\nstate, which can then flow through a series of **calculations** which perform\r\nfurther updates of the state, and finally into a bunch of **side-effects**\r\nwhich do stuff with the resulting state.\r\n\r\nThis diagram illustrates the flow of data through a Fluxlet...\r\n\r\n![Fluxlet data flow](fluxlet-data-flow.png)\r\n\r\nThe lines represent the actual flow of data, green is data from the event,\r\nand red is the state. The shaded rectangles are functions.\r\n\r\n## Why?\r\n\r\nThe whole point of this is that from any action dispatch (knowing the payload\r\nand starting state), you should be able to reason about (and reliably test)\r\nthe end state, and know exactly what side-effects should be performed. You\r\nshould be able to reason about the exact state of your application and what\r\nasync tasks it's performing at any time.\r\n\r\n\r\n## The Component Functions\r\n\r\nAn **action** is a pure function that takes a payload and a state and returns\r\na new state.\r\n\r\n_I lied a little, an action function actually takes the payload and returns\r\nanother function that takes the state, the reasons for this become clear when\r\nyou create actions using immutable state update functions._\r\n\r\nThe new state from the action is passed into a chain of **calculations**,\r\nwhich are also pure functions that take state and return new state.\r\n\r\nThe state from the last calculation is then passed into all of the\r\n**side-effects**, which are functions that take the state and do stuff,\r\neg. render to DOM, make requests, but they can't directly affect the state.\r\n\r\n\r\nFor the sake of clarity, there is some detail missing from the diagram above:\r\nThe initial state is also passed to every calculation and side-effect so that\r\nthey can compare the current state to the previous state to determine if they\r\nactually need to do anything. This previous state should be used simply for\r\ncomparison purposes.\r\n\r\nAn overview of the component function signatures:\r\n\r\n- **action**: (...payload) -> (initial-state) -> transient-state\r\n- **calculation**: (transient-state, initial-state) -> transient-state\r\n- **side effect**: (final-state, initial-state, dispatchers) -> void\r\n\r\n_The state from the final calculation in the chain (or the action if no\r\ncalculations are called) becomes the final state_\r\n\r\nYou explicitly register these component functions with a Fluxlet using its\r\nfluent API at construction time.\r\n\r\n\r\n## Dispatchers\r\n\r\nFluxlet creates a separate **dispatcher** function for every action, but they\r\nall call a shared set of calculations and side-effects.\r\n\r\nIt's these dispatcher functions that are called from async event handlers, or\r\nother fluxlets.\r\n\r\n\r\n## One Big Immutable State\r\n\r\nState within a Fluxlet is a single immutable JS object, the state must NEVER\r\nbe modified by a component function. **Actions** and **calculations** must\r\neither return the same unmodified state or a new version of the state.\r\n\r\n_TODO: Could do with a reference to how immutable data structures work here_\r\n\r\n\r\n## The Rules\r\n\r\n**Action** and **calculation** functions must be _pure referentially\r\ntransparent_ functions, that is, they can use data given to them and should\r\nreturn a consistent state from the data passed in - they MUST NEVER use data\r\nfrom elsewhere or perform any side-effects.\r\n\r\n**Side-effects** on the other hand, as the name suggests can perform\r\nside-effects, but they can not alter state or directly dispatch another action.\r\nThey can however call an action dispatcher from within an async event\r\nhandler, eg. timeout, ajax callback.\r\n\r\nA **side-effect** should do as little as possible, delegating any data\r\nprocessing to a **calculation** wherever possible. It should also source any\r\ntransient data from the state and not directly from the DOM, ie. form values\r\nshould be fed into the state via an action. Keeping the state as the\r\nauthoritative state of the application at any time. Although it may check the\r\nDOM to determine whether it needs to update it or not.\r\n\r\n\r\n## Example\r\n\r\n```javascript\r\nimport fluxlet from \"fluxlet\"\r\nimport { update } from \"fluxlet-immutable/update\"\r\n\r\nexport default function() {\r\n  fluxlet('hello-world')\r\n    .state({\r\n      name: '',\r\n      response: ''\r\n    })\r\n    .actions({ setName })\r\n    .calculations({ formulateResponse })\r\n    .sideEffects({ deliverResponse })\r\n    .init(bindGlobalEvents)\r\n}\r\n\r\nfunction bindGlobalEvents(dispatch) {\r\n  document.getElementById(\"id\")\r\n    .addEventListener(\"input\", (event) => dispatch.setName(event.target.value))\r\n}\r\n\r\n// Actions\r\nconst setName = (name) => update('name', name)\r\n\r\n// Calculations\r\nconst formulateResponse = update('response', (x, state) => `Hello ${state.name}`)\r\n\r\n// Side-Effects\r\nconst deliverResponse = (state) => {\r\n  document.getElementById(\"out\").textContent = state.response\r\n}\r\n```\r\n\r\nThis example uses the *update* function from the\r\n[fluxlet-immutable](https://github.com/fluxlet/fluxlet-immutable) library, which is in a separate\r\npackage as you may want to use whatever immutable library you prefer.\r\n\r\nFor a richer example see the\r\n[fluxlet-example-todomvc](https://github.com/fluxlet/fluxlet-example-todomvc).\r\n\r\nOh and btw, all of the Fluxlet code, additional libraries and examples are\r\nwritten and take advantage of ECMAScript 2015 syntax, but only use API features\r\nfrom ES5.\r\n\r\n\r\n## Documentation\r\n\r\nRead the [fluxlet source](src/fluxlet.js) source, and/or the _groc_ generated\r\ndocs.\r\n\r\nDocs can be generated using groc:\r\n\r\n    $ groc\r\n\r\nAnd then opened directly from the filesystem in a browser.\r\n\r\n\r\n## Installing\r\n\r\n### Using [jspm](http://jspm.io)\r\n\r\n    $ jspm install fluxlet=github:fluxlet/fluxlet@master\r\n\r\n### Using [npm](https://www.npmjs.com/)\r\n\r\n    $ npm install fluxlet\r\n\r\n### Using [bower](http://bower.io/)\r\n\r\n    $ bower install fluxlet/fluxlet\r\n\r\nYou'll find the ES6 src in _bower_components/fluxlet/src/fluxlet.js_,\r\nwhich will need to be transpiled using your favourite tools.\r\n\r\n\r\n## Testing Fluxlets\r\n\r\nTo make testing of fluxlets easier a test library,\r\n[testlet](https://github.com/fluxlet/fluxlet-testlet), provides a fluent API\r\nfor setting up fluxlets, dispatching actions, and checking state using a\r\ngiven/when/then style.\r\n\r\n\r\n## Development\r\n\r\n    $ npm install\r\n\r\n\r\n## Tests\r\n\r\nTest are run using karma and jspm:\r\n\r\n    $ npm test\r\n\r\nor\r\n\r\n    $ jspm install\r\n    $ karma start\r\n\r\nThere is also a config for Wallaby if you have it installed in your IDE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}